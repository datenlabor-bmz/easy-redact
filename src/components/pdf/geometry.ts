import type { Redaction, RedactionPart, BoundingBox, HighlightInProgress, PageData } from '@/types'

export function generateUUID(): string {
  return crypto.randomUUID()
}

export function boundingBox(redaction: Redaction): BoundingBox {
  const xs0 = redaction.parts.map(p => p.x)
  const ys0 = redaction.parts.map(p => p.y)
  const xs1 = redaction.parts.map(p => p.x + p.width)
  const ys1 = redaction.parts.map(p => p.y + p.height)
  return { x0: Math.min(...xs0), y0: Math.min(...ys0), x1: Math.max(...xs1), y1: Math.max(...ys1) }
}

export function quadToPart(quad: number[]): RedactionPart {
  const [x0, y0, x1, y1, x2, y2, x3, y3] = quad
  const x = Math.min(x0, x1, x2, x3)
  const y = Math.min(y0, y1, y2, y3)
  return { x, y, width: Math.max(x0, x1, x2, x3) - x, height: Math.max(y0, y1, y2, y3) - y }
}

export function finalizeHighlight(page: PageData, highlight: HighlightInProgress): Redaction {
  if (highlight.type === 'freehand') {
    const x = Math.min(highlight.startX, highlight.endX)
    const y = Math.min(highlight.startY, highlight.endY)
    return {
      id: generateUUID(), documentKey: '', pageIndex: highlight.pageIndex,
      parts: [{ x, y, width: Math.abs(highlight.endX - highlight.startX), height: Math.abs(highlight.endY - highlight.startY) }],
      status: 'manual', shouldApply: true, isAutoGenerated: false,
    }
  }

  const hl_x0 = Math.min(highlight.startX, highlight.endX)
  const hl_x1 = Math.max(highlight.startX, highlight.endX)
  const hl_y0 = Math.min(highlight.startY, highlight.endY)
  const hl_y1 = Math.max(highlight.startY, highlight.endY)

  const intersecting = page.lines.filter((line: any) => {
    const { x, y, w, h } = line.bbox
    return x <= hl_x1 && x + w >= hl_x0 && y <= hl_y1 && y + h >= hl_y0
  })

  const isTopDown = highlight.endY > highlight.startY
  const topWord = isTopDown ? highlight.startWord : highlight.endWord
  const bottomWord = isTopDown ? highlight.endWord : highlight.startWord

  const parts = intersecting.map((line: any, i: number) => {
    const { y, h } = line.bbox
    let { x, w } = line.bbox
    const isTop = i === 0, isBottom = i === intersecting.length - 1
    if (topWord && bottomWord && isTop && isBottom) {
      x = topWord.bbox.x0; w = bottomWord.bbox.x1 - x
    } else if (topWord && isTop) {
      const dx = topWord.bbox.x0 - x; x = topWord.bbox.x0; w -= dx
    } else if (bottomWord && isBottom) {
      w -= x + w - bottomWord.bbox.x1
    }
    return { x, y, width: w, height: h }
  })

  return { id: generateUUID(), documentKey: '', pageIndex: highlight.pageIndex, parts, status: 'manual', shouldApply: true, isAutoGenerated: false }
}

export function redactionsToAnnotations(redactions: Redaction[]) {
  return redactions.filter(r => r.status !== 'ignored' && r.shouldApply !== false).map(r => ({
    content: r.rule?.title || '',
    position: {
      pageNumber: r.pageIndex,
      rect: [r.parts[0].x, r.parts[0].y, r.parts[0].x + r.parts[0].width, r.parts[0].y + r.parts[0].height],
      quads: r.parts.map(p => [p.x, p.y, p.x + p.width, p.y, p.x, p.y + p.height, p.x + p.width, p.y + p.height]),
    },
  }))
}

export function getRedactionText(redaction: Redaction, page: PageData): string {
  const bbox = boundingBox(redaction)
  const words = [...page.words].sort((a, b) => {
    const dy = a.bbox.y0 - b.bbox.y0
    return Math.abs(dy) > 5 ? dy : a.bbox.x0 - b.bbox.x0
  })
  return words
    .filter(w => !(w.bbox.x1 < bbox.x0 || w.bbox.x0 > bbox.x1 || w.bbox.y1 < bbox.y0 || w.bbox.y0 > bbox.y1))
    .map(w => w.text)
    .join(' ')
}
