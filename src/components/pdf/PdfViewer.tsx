'use client'

import { useEffect, useRef, useState } from 'react'
import type { Redaction, PageData, HighlightInProgress, WordData, RedactionSuggestion } from '@/types'
import { useMupdf } from './useMupdf'
import { finalizeHighlight, redactionsToAnnotations, quadToPart, generateUUID } from './geometry'
import { PdfPage } from './PdfPage'
import { Loader2 } from 'lucide-react'

export interface PdfViewerProps {
  file: File
  redactions: Redaction[]
  selectedId: string | null
  zoom: number
  onRedactionAdd: (r: Redaction) => void
  onRedactionRemove: (id: string) => void
  onRedactionUpdate: (id: string, updates: Partial<Redaction>) => void
  onSelectionChange: (id: string | null) => void
  onZoomChange: (zoom: number) => void
  onExport: (blob: Blob, applied: boolean) => void
  onPageTextExtracted?: (text: string, pageIndex: number) => void
  onPagesLoaded?: (pages: PageData[]) => void
  pendingSuggestions?: RedactionSuggestion[]
  onSuggestionsApplied?: () => void
  exportRef?: React.MutableRefObject<((apply: boolean) => void) | null>
}

export function PdfViewer({
  file, redactions, selectedId, zoom, onRedactionAdd, onRedactionRemove,
  onRedactionUpdate, onSelectionChange, onZoomChange, onExport,
  onPageTextExtracted, onPagesLoaded, pendingSuggestions, onSuggestionsApplied, exportRef,
}: PdfViewerProps) {
  const { isWorkerInitialized, renderPage, loadDocumentAndAnnotations, countPages,
    getPageContent, getPageBounds, getPageWords, getRedactedDocument, searchPage } = useMupdf()

  const [pages, setPages] = useState<PageData[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [currentHighlight, setCurrentHighlight] = useState<HighlightInProgress | null>(null)
  const pdfViewerRef = useRef<HTMLDivElement>(null)

  // Load document
  useEffect(() => {
    if (!isWorkerInitialized || !file) return

    const init = async () => {
      setPages([])
      setIsLoading(true)
      const buf = await file.arrayBuffer()
      const existing = await loadDocumentAndAnnotations(buf)
      existing.forEach((ann: any) => {
        const parts = ann.quads.map((q: number[]) => quadToPart(q))
        onRedactionAdd({ id: generateUUID(), documentKey: '', pageIndex: ann.pageIndex, parts, status: 'manual', shouldApply: true })
      })

      const total = await countPages()
      const stack: PageData[] = []
      for (let i = 0; i < total; i++) {
        const pngData = await renderPage(i)
        const content = JSON.parse(await getPageContent(i))
        const lines = content.blocks.flatMap((b: any) => b.lines)
        const words = await getPageWords(i)
        if (onPageTextExtracted) {
          const text = lines.map((l: any) => l.text ?? l.spans?.map((s: any) => s.text).join('') ?? '').join(' ')
          onPageTextExtracted(text, i)
        }
        stack.push({
          image: URL.createObjectURL(new Blob([new Uint8Array(pngData)], { type: 'image/png' })),
          bounds: await getPageBounds(i),
          content, lines, words,
        })
      }
      setPages(stack)
      onPagesLoaded?.(stack)
      setIsLoading(false)
    }
    init()
  }, [isWorkerInitialized, file])

  // Apply AI suggestions by searching text in PDF
  useEffect(() => {
    if (!pendingSuggestions?.length || !pages.length) return
    ;(async () => {
      for (const s of pendingSuggestions) {
        const quads = await searchPage(s.pageIndex, s.text)
        if (quads.length === 0) continue
        // quads is Quad[][] - outer array = matches, inner = quads per match
        const parts = (quads as number[][][]).flat().map(q => quadToPart(q as number[]))
        onRedactionAdd({
          id: generateUUID(), documentKey: '', pageIndex: s.pageIndex, parts,
          status: 'suggested', confidence: s.confidence,
          person: s.person, personGroup: s.personGroup,
          rule: s.rule, reason: s.reason,
          isAutoGenerated: true, shouldApply: true,
        })
      }
      onSuggestionsApplied?.()
    })()
  }, [pendingSuggestions])

  const scrollToPage = (idx: number) => {
    const el = pdfViewerRef.current?.querySelectorAll('[data-page-index]')[idx] as HTMLElement
    el?.scrollIntoView({ behavior: 'smooth', block: 'center' })
  }

  const handleMouseDown = (e: React.MouseEvent<SVGSVGElement>, pageIndex: number) => {
    if ((e.target as Element).closest('g[data-highlight="true"]')) return
    const page = pages[pageIndex]
    const [, , pw, ph] = page.bounds
    const rect = e.currentTarget.getBoundingClientRect()
    const x = (e.clientX - rect.left) * (pw / rect.width)
    const y = (e.clientY - rect.top) * (ph / rect.height)
    const startWord = page.words.find((w: WordData) => x >= w.bbox.x0 && x <= w.bbox.x1 && y >= w.bbox.y0 && y <= w.bbox.y1) ?? null
    setCurrentHighlight({ pageIndex, type: startWord ? 'text' : 'freehand', startX: x, startY: y, endX: x, endY: y, startWord, endWord: startWord })
  }

  const handleMouseMove = (e: React.MouseEvent<SVGSVGElement>) => {
    if (!currentHighlight) return
    const page = pages[currentHighlight.pageIndex]
    const [, , pw, ph] = page.bounds
    const rect = e.currentTarget.getBoundingClientRect()
    const cx = (e.clientX - rect.left) * (pw / rect.width)
    const cy = (e.clientY - rect.top) * (ph / rect.height)
    const endWord = currentHighlight.type === 'text'
      ? (page.words.find((w: WordData) => cx >= w.bbox.x0 && cx <= w.bbox.x1 && cy >= w.bbox.y0 && cy <= w.bbox.y1) ?? currentHighlight.endWord)
      : currentHighlight.endWord
    setCurrentHighlight({ ...currentHighlight, endX: cx, endY: cy, endWord })
  }

  const handleMouseUp = () => {
    if (currentHighlight) {
      const r = finalizeHighlight(pages[currentHighlight.pageIndex], currentHighlight)
      if (currentHighlight.type === 'freehand' && r.parts[0].width * r.parts[0].height < 100) {
        setCurrentHighlight(null); return
      }
      onRedactionAdd(r)
    }
    setCurrentHighlight(null)
  }

  const handleExport = async (apply: boolean) => {
    const annotations = redactionsToAnnotations(redactions)
    const blob = await getRedactedDocument(annotations, apply)
    onExport(blob, apply)
  }

  // Expose export trigger to parent via ref
  if (exportRef) exportRef.current = handleExport

  if (isLoading) return (
    <div className='flex flex-col items-center justify-center flex-1 gap-3 text-muted-foreground bg-muted'>
      <Loader2 className='h-8 w-8 animate-spin' />
      <p className='text-sm'>PDF wird geladenâ€¦</p>
    </div>
  )

  return (
    <div className='flex flex-col h-full'>
      {/* Pages */}
      <div ref={pdfViewerRef} className='flex-1 overflow-auto flex flex-col items-center bg-muted'>
        {pages.map((page, i) => (
          <PdfPage key={i} pageIndex={i} pageData={page} zoom={zoom} redactions={redactions}
            selectedId={selectedId} currentHighlight={currentHighlight}
            onRedactionClick={(id, e) => { e.stopPropagation(); onSelectionChange(id) }}
            onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} />
        ))}
      </div>
    </div>
  )
}
